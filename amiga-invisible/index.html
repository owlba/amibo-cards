
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Mini‚Äëcrafting ‚Äî Carta de la amiga invisible</title>
  <style>
    :root{
      --ui:#0f172a;
      --panelW:min(480px,96vw);
    }
    html,body{height:100%;margin:0;background:#f0f9ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    header{width:var(--panelW);margin:14px auto 10px;display:flex;justify-content:space-between;align-items:center;color:var(--ui)}
    header .stat{display:flex;gap:12px;align-items:center;font-weight:600}
    .badge{padding:6px 10px;border-radius:12px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.07)}
    canvas{display:block;margin:6px auto;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.12);touch-action:none}
    #panel{width:var(--panelW);margin:10px auto 18px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    .btn{appearance:none;border:none;background:#fff;color:#0f172a;border-radius:12px;padding:8px 12px;box-shadow:0 2px 10px rgba(0,0,0,.1);font-weight:600}
    .btn:active{transform:translateY(1px)}
    #power{background:linear-gradient(180deg,#ffe082,#ffd54f)}
    #power[disabled]{filter:grayscale(.8);opacity:.7}
    footer{width:var(--panelW);margin:6px auto 22px;color:#3c4a4a;font-size:.92rem;text-align:center}
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35)}
    #overlay .card{width:min(520px,92vw);background:#fff;color:#0f172a;padding:18px;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);text-align:center}
    @media (max-width:420px){ header{font-size:14px} }
  </style>
</head>
<body>
  <header>
    <div class="stat">
      <span class="badge">‚åõ <strong id="time">00:00</strong></span>
      <span class="badge">üéØ Puntos: <strong id="score">0</strong></span>
      <span class="badge">üß∞ Receta: <strong id="recipe">‚Äî</strong></span>
    </div>
    <div class="stat">
      <span class="badge">üèÜ R√©cord: <strong id="best">0</strong></span>
      <button class="btn" id="pause">‚è∏Ô∏è Pausa</button>
    </div>
  </header>

  <canvas id="game" width="360" height="640" aria-label="Mini-crafting"></canvas>

  <div id="panel">
    <button class="btn" id="power" title="Comod√≠n (coloca un √≠tem que falte) ‚Äî 1 uso">üÉè Comod√≠n</button>
    <button class="btn" id="restart">üîÑ Reiniciar</button>
  </div>

  <footer>
    Carta: <strong>amiga invisible</strong>
  </footer>

  <div id="overlay" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Mini‚Äëcrafting</h2>
      <p>Arrastra las <strong>herramientas y recursos correctos</strong> a la caja de trabajo. Completa la receta antes de que acabe el tiempo. Tienes un <em>Comod√≠n</em> (1 uso).</p>
      <ul style="text-align:left;max-width:480px;margin:10px auto;">
        <li><strong>Movimiento:</strong> toca un √≠tem y arr√°stralo. Su√©ltalo sobre la caja.</li>
        <li><strong>Recetas:</strong> 3 niveles; cada uno exige 3 √≠tems.</li>
        <li><strong>Puntuaci√≥n:</strong> +50 por √≠tem correcto, +100 por receta completa, combo por rapidez.</li>
      </ul>
      <button class="btn" id="start">‚ñ∂Ô∏è Empezar</button>
    </div>
  </div>

<script>
(() => {
  /* ===================== Canvas y escala ===================== */
  const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const baseW = canvas.width, baseH = canvas.height;
  canvas.width = baseW * DPR; canvas.height = baseH * DPR;
  canvas.style.width = baseW + 'px'; canvas.style.height = baseH + 'px';
  ctx.scale(DPR, DPR);

  /* ===================== UI ===================== */
  const timeEl = document.getElementById('time');
  const scoreEl = document.getElementById('score');
  const recipeEl = document.getElementById('recipe');
  const bestEl = document.getElementById('best');
  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('start');
  const pauseBtn = document.getElementById('pause');
  const restartBtn = document.getElementById('restart');
  const powerBtn = document.getElementById('power');

  const RECORD_KEY = 'crafting_best_amiga';
  bestEl.textContent = +localStorage.getItem(RECORD_KEY) || 0;

  /* ===================== Paletas por receta (cielo/suelo) ===================== */
  const THEMES = {
    'Colgar cuadro':   { sky:'#e3f2fd', floor:'#c8e6c9' }, // azul claro + verde
    'Reparar libro':   { sky:'#fff3e0', floor:'#ffe0b2' }, // crema + melocot√≥n
    'Pintar esquina':  { sky:'#fce4ec', floor:'#f8bbd0' }  // rosa pastel
  };

  /* ===================== Mundo ===================== */
  const world = { w: baseW, h: baseH, groundY: baseH-60, running:false, paused:false, time:0, duration:75_000 };
  const box = { x: baseW/2-90, y: world.groundY-120, w: 180, h: 110, slots: [] }; // caja m√°s amplia

  /* ===================== Protagonista ===================== */
  const hero = { x: baseW/2-28, y: world.groundY-190, w: 56, h: 96, sprite:new Image() };
  hero.sprite.src = 'assets/amiga-invisible.png';

  /* ===================== Carga de iconos personalizados ===================== */
  // 1) PON AQU√ç TUS ARCHIVOS PNG/SVG EN LA CARPETA /assets/
  //    Si no aportas un icono, el juego dibuja un vector de respaldo.
  const ICON_IMG_SRC = {
    martillo:  'assets/martillo.png',
    clavos:    'assets/clavos.png',
    nivel:     'assets/nivel.png',         // nivel de burbuja
    pegamento: 'assets/pegamento.png',
    clip:      'assets/clip.png',
    papel:     'assets/papel.png',
    pincel:    'assets/pincel.png',
    paleta:    'assets/paleta.png',
    carrocero: 'assets/carrocero.png'      // cinta de carrocero
  };
  const ICON_IMG = Object.fromEntries(
    Object.entries(ICON_IMG_SRC).map(([k,src]) => {
      const img = new Image();
      img.src = src;   // si el archivo no existe o no carga, se usar√° el vector
      return [k, img];
    })
  );

  /* ===================== Vector de respaldo (plano, vibrante) ===================== */
  const ITEMS = [
    { key:'martillo', draw:(x,y,s)=>{ ctx.fillStyle='#546e7a'; ctx.fillRect(x-s*0.45,y-s*0.10,s*0.9,s*0.22); ctx.fillStyle='#8d6e63'; ctx.fillRect(x-s*0.06,y+s*0.12,s*0.12,s*0.70); }},
    { key:'clavos', draw:(x,y,s)=>{ ctx.fillStyle='#37474f'; for(let i=0;i<3;i++){ const ox=-s*0.25+i*s*0.25; ctx.fillRect(x+ox,y-s*0.05, s*0.08, s*0.40); ctx.fillRect(x+ox-2,y-s*0.08, s*0.12, s*0.06); } }},
    { key:'nivel', draw:(x,y,s)=>{ ctx.fillStyle='#43a047'; ctx.fillRect(x-s*0.40,y-s*0.12,s*0.80,s*0.24); ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fillRect(x-s*0.30,y-s*0.06,s*0.60,s*0.12); ctx.fillStyle='#ffeb3b'; ctx.beginPath(); ctx.arc(x, y, s*0.04, 0, Math.PI*2); ctx.fill(); }},
    { key:'papel', draw:(x,y,s)=>{ ctx.fillStyle='#eceff1'; roundRectPath(x-s*0.28,y-s*0.34,s*0.56,s*0.68,10); ctx.fill(); ctx.fillStyle='#b0bec5'; ctx.fillRect(x-s*0.20, y-s*0.20, s*0.40, s*0.04); ctx.fillRect(x-s*0.20, y-s*0.10, s*0.36, s*0.04); ctx.fillRect(x-s*0.20, y, s*0.28, s*0.04); }},
    { key:'carrocero', draw:(x,y,s)=>{ ctx.fillStyle='#ffd54f'; ctx.beginPath(); ctx.arc(x,y,s*0.24,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.arc(x,y,s*0.12,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; ctx.fillStyle='#ffca28'; ctx.fillRect(x+s*0.12, y-s*0.02, s*0.22, s*0.08); }},
    { key:'pegamento', draw:(x,y,s)=>{ ctx.fillStyle='#ef5350'; ctx.fillRect(x-s*0.18,y-s*0.10,s*0.36,s*0.46); ctx.fillStyle='#fff'; ctx.fillRect(x-s*0.14,y+s*0.02,s*0.28,s*0.18); ctx.fillStyle='#b71c1c'; ctx.fillRect(x-s*0.06,y-s*0.26,s*0.12,s*0.16); }},
    { key:'pincel', draw:(x,y,s)=>{ ctx.fillStyle='#8d6e63'; ctx.beginPath(); ctx.moveTo(x-s*0.24,y+s*0.28); ctx.lineTo(x,y-s*0.06); ctx.lineTo(x+s*0.24,y+s*0.28); ctx.closePath(); ctx.fill(); ctx.fillStyle='#90caf9'; ctx.fillRect(x-s*0.08,y-s*0.40,s*0.16,s*0.32); }},
    { key:'paleta', draw:(x,y,s)=>{ ctx.fillStyle='#ffe082'; ctx.beginPath(); ctx.arc(x,y,s*0.40,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='destination-out'; ctx.beginPath(); ctx.arc(x+s*0.20,y,s*0.12,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; ['#ef5350','#66bb6a','#42a5f5','#ab47bc'].forEach((c,i)=>{ ctx.fillStyle=c; ctx.beginPath(); ctx.arc(x- s*0.20 + i*s*0.12, y+s*0.10 - (i%2)*s*0.06, s*0.06,0,Math.PI*2); ctx.fill(); }); }},
    { key:'clip', draw:(x,y,s)=>{ ctx.strokeStyle='#546e7a'; ctx.lineWidth = Math.max(2, s*0.12); ctx.beginPath(); ctx.moveTo(x-s*0.14,y-s*0.02); ctx.quadraticCurveTo(x+s*0.20,y-s*0.10, x+s*0.12,y+s*0.28); ctx.quadraticCurveTo(x,y+s*0.40, x-s*0.10,y+s*0.18); ctx.stroke(); } }
  ];

  // Dibuja imagen personalizada si existe; si no, vector de respaldo
  function drawItemWithImageOrVector(key, cx, cy, s){
    const img = ICON_IMG[key];
    // Si la imagen est√° cargada, la dibujamos centrada; si no, usamos vector
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, cx - s*0.5, cy - s*0.5, s, s);
    } else {
      const def = ITEMS.find(i => i.key === key);
      def?.draw(cx, cy, s);
    }
  }

  /* ===================== Recetas ===================== */
  const RECIPES = [
    { name:'Colgar cuadro', need:['martillo','clavos','nivel'] },
    { name:'Reparar libro',  need:['pegamento','clip','papel'] },
    { name:'Pintar esquina', need:['pincel','paleta','carrocero'] }
  ];

  /* Etiquetas visibles (m√°s claras) */
  const DISPLAY = {
    martillo:'Martillo', clavos:'Clavos', nivel:'Nivel de burbuja',
    pegamento:'Pegamento', clip:'Clip', papel:'Hoja de papel',
    pincel:'Pincel', paleta:'Paleta', carrocero:'Cinta de carrocero'
  };

  /* ===================== Estado ===================== */
  let score=0, combo=1, comboTimer=0, level=0, currentRecipe=null;

  /* ===================== Bancada: √≠tems arrastrables ===================== */
  const bench = { items:[] };
  function spawnBenchFor(recipe){
    bench.items = [];
    const need = recipe.need.slice();
    const pool = ITEMS.map(it=>it.key);

    // 3 necesarios + 3 distractores (sin duplicar excesivo)
    while(bench.items.length < 6){
      const k = bench.items.length < need.length ? need[bench.items.length] : pool[Math.floor(Math.random()*pool.length)];
      const countK = bench.items.filter(i=>i.key===k).length;
      if (countK > 1 && !need.includes(k)) continue;

      bench.items.push({
        key: k,
        x: 60 + (bench.items.length%3)*100,
        y: 120 + Math.floor(bench.items.length/3)*115,
        s: 48,
        dragging:false, dx:0, dy:0, placed:false
      });
    }
  }

  /* ===================== Slots de la caja (m√°s separados y con ‚Äúp√≠ldora‚Äù de texto) ===================== */
  function buildSlots(recipe){
    const spacing = 70;              // separaci√≥n mayor entre slots
    const slotW = 46, slotH = 46;    // slot un poco mayor
    box.slots = recipe.need.map((key,i)=>({
      key,
      x: box.x + 18 + i*spacing,
      y: box.y + 18,
      w: slotW,
      h: slotH,
      filled:false
    }));
  }

  /* ===================== HUD ===================== */
  function updateHUD(){
    scoreEl.textContent = score;
    recipeEl.textContent = currentRecipe ? currentRecipe.name : '‚Äî';
    const remain = Math.max(0, Math.ceil((world.duration - world.time)/1000));
    timeEl.textContent = String(Math.floor(remain/60)).padStart(2,'0') + ':' + String(remain%60).padStart(2,'0');
  }

  /* ===================== Juego ===================== */
  function startGame(){
    score=0; combo=1; comboTimer=0; level=0; world.time=0;
    currentRecipe = RECIPES[level];
    spawnBenchFor(currentRecipe); buildSlots(currentRecipe);
    world.running=true; world.paused=false;
    overlay.style.display='none';
    powerBtn.disabled=false; pauseBtn.textContent='‚è∏Ô∏è Pausa';
    loop(performance.now());
  }

  function endGame(win){
    world.running=false;
    const best = +localStorage.getItem(RECORD_KEY) || 0;
    localStorage.setItem(RECORD_KEY, Math.max(best, score));
    bestEl.textContent = localStorage.getItem(RECORD_KEY);
    document.getElementById('start').textContent = '‚ñ∂Ô∏è Repetir';
    const title = win ? '¬°Recetas completadas!' : 'Se acab√≥ el tiempo';
    document.querySelector('#overlay .card h2').textContent = title;
    document.querySelector('#overlay .card p').innerHTML =
      `Puntos: <strong>${score}</strong> ¬∑ R√©cord: <strong>${bestEl.textContent}</strong><br>`+
      `Receta actual: <strong>${currentRecipe?.name||'‚Äî'}</strong>`;
    overlay.style.display='flex';
  }

  /* ===================== Update & Draw ===================== */
  function update(dt){
    if (world.paused) return;
    world.time += dt;
    if (world.time >= world.duration) return endGame(false);

    // Combo
    if (comboTimer>0){ comboTimer -= dt; if (comboTimer<=0){ comboTimer=0; combo=1; } }
  }

  function draw(){
    ctx.clearRect(0,0,world.w, world.h);

    // Fondo seg√∫n la receta
    const theme = THEMES[currentRecipe?.name] || { sky:'#bbdefb', floor:'#a5d6a7' };
    ctx.save();
    ctx.fillStyle = theme.sky;   ctx.fillRect(0,0,world.w, world.h*0.70);
    ctx.fillStyle = theme.floor; ctx.fillRect(0,world.h*0.70, world.w, world.h*0.30);
    ctx.restore();

    // Protagonista
    ctx.drawImage(hero.sprite, hero.x, hero.y, hero.w, hero.h);

    // Caja
    ctx.fillStyle='#8d6e63'; roundRect(box.x, box.y, box.w, box.h, 12, true);
    ctx.fillStyle='#6d4c41'; roundRect(box.x+8, box.y+64, box.w-16, 18, 8, true);

    // Slots + etiquetas m√°s legibles (p√≠ldora)
    box.slots.forEach(sl=>{
      ctx.fillStyle= sl.filled ? '#81c784' : '#ffffff';
      roundRect(sl.x, sl.y, sl.w, sl.h, 8, true);

      // etiqueta debajo (separaci√≥n mayor + fondo)
      const label = DISPLAY[sl.key] || sl.key;
      const padX = 8, padY = 6;
      ctx.font = 'bold 12px system-ui';
      const textW = ctx.measureText(label).width;
      const pillW = Math.max(textW + padX*2, sl.w + 16);
      const pillH = 22;
      const pillX = sl.x + sl.w/2 - pillW/2;
      const pillY = sl.y + sl.h + 24;

      // fondo de etiqueta
      ctx.fillStyle = '#ffffff';
      roundRect(pillX, pillY, pillW, pillH, 12, true);
      ctx.strokeStyle = 'rgba(0,0,0,.08)'; ctx.stroke();

      // texto centrado
      ctx.fillStyle = '#263238';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, pillX + pillW/2 - textW/2, pillY + pillH/2);
    });

    // Bancada
    ctx.fillStyle='#b0bec5'; roundRect(20, 90, world.w-40, 10, 6, true);

    // √çtems (imagen personalizada si existe; si no, vector)
    bench.items.forEach(it=>{
      if (it.placed) return;
      const cx = it.x + (it.dragging ? it.dx : 0);
      const cy = it.y + (it.dragging ? it.dy : 0);
      ctx.fillStyle='rgba(0,0,0,.06)'; ctx.beginPath(); ctx.arc(cx, cy+it.s*0.56, it.s*0.36, 0, Math.PI*2); ctx.fill();
      drawItemWithImageOrVector(it.key, cx, cy, it.s);
    });

    // HUD dentro del canvas (tiempo restante peque√±o)
    ctx.fillStyle='rgba(0,0,0,.25)'; roundRect(12, 12, 110, 28, 8, true);
    ctx.fillStyle='#fff'; ctx.font='bold 14px system-ui';
    const remain = Math.max(0, Math.ceil((world.duration - world.time)/1000));
    ctx.fillText(`‚è± ${remain}s`, 20, 31);
  }

  function loop(ts){
    if (!world.running) return;
    const dt = Math.min(32, ts - (loop._last || ts)); loop._last = ts;
    update(dt);
    updateHUD();
    draw();
    requestAnimationFrame(loop);
  }

  /* ===================== Utilidades de dibujo ===================== */
  function roundRect(x,y,w,h,r, fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    if (fill) ctx.fill(); else ctx.stroke();
  }
  function roundRectPath(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
  }

  /* ===================== Drag & drop ===================== */
  let dragging=null;
  function pickItemAt(px,py){
    for(let i=bench.items.length-1;i>=0;i--){
      const it = bench.items[i];
      if (it.placed) continue;
      const cx = it.x + (it.dragging ? it.dx : 0);
      const cy = it.y + (it.dragging ? it.dy : 0);
      if (px>cx-30 && px<cx+30 && py>cy-30 && py<cy+30){
        return it;
      }
    }
    return null;
  }
  function onPointerDown(ev){
    const rect = canvas.getBoundingClientRect();
    const x = (ev.touches? ev.touches[0].clientX: ev.clientX) - rect.left;
    const y = (ev.touches? ev.touches[0].clientY: ev.clientY) - rect.top;
    dragging = pickItemAt(x,y);
    if (dragging){ dragging.dragging=true; dragging.dx=0; dragging.dy=0; }
  }
  function onPointerMove(ev){
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = (ev.touches? ev.touches[0].clientX: ev.clientX) - rect.left;
    const y = (ev.touches? ev.touches[0].clientY: ev.clientY) - rect.top;
    dragging.dx = x - dragging.x;
    dragging.dy = y - dragging.y;
    ev.preventDefault();
  }
  function onPointerUp(){
    if (!dragging) return;
    const dropX = dragging.x + dragging.dx, dropY = dragging.y + dragging.dy;
    let placed=false;
    for (const sl of box.slots){
      if (sl.filled) continue;
      if (dropX>sl.x && dropX<sl.x+sl.w && dropY>sl.y && dropY<sl.y+sl.h){
        if (dragging.key === sl.key){
          sl.filled=true; dragging.placed=true; placed=true;
          const gained = Math.floor(50 * combo);
          score += gained; combo = Math.min(5, combo+1); comboTimer = 1600;
          if (box.slots.every(s=>s.filled)){
            score += 100 * combo; combo = Math.min(5, combo+1); comboTimer = 1600;
            level++;
            if (level >= RECIPES.length) { return endGame(true); }
            currentRecipe = RECIPES[level];
            spawnBenchFor(currentRecipe); buildSlots(currentRecipe);
          }
        }
        break;
      }
    }
    if (!placed){ dragging.dx=0; dragging.dy=0; }
    dragging.dragging=false; dragging=null;
  }
  canvas.addEventListener('mousedown', onPointerDown);
  canvas.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);
  canvas.addEventListener('touchstart', onPointerDown, {passive:false});
  canvas.addEventListener('touchmove', onPointerMove, {passive:false});
  window.addEventListener('touchend', onPointerUp);

  /* ===================== Pausa y reinicio ===================== */
  pauseBtn.addEventListener('click', ()=>{ if (!world.running) return; world.paused=!world.paused; pauseBtn.textContent = world.paused? '‚ñ∂Ô∏è Reanudar':'‚è∏Ô∏è Pausa'; });
  restartBtn.addEventListener('click', ()=>{ world.running=false; overlay.style.display='flex'; });

  /* ===================== Comod√≠n ===================== */
  powerBtn.addEventListener('click', ()=>{
    if (!world.running || world.paused || powerBtn.disabled) return;
    const sl = box.slots.find(s=>!s.filled);
    if (!sl) return;
    powerBtn.disabled=true;
    sl.filled=true;
    const it = bench.items.find(i=>!i.placed && i.key===sl.key);
    if (it) it.placed=true;
    score += Math.floor(50 * combo);
    combo = Math.min(5, combo+1); comboTimer = 1600;
    if (box.slots.every(s=>s.filled)){
      score += 100 * combo; combo = Math.min(5, combo+1); comboTimer = 1600;
      level++;
      if (level >= RECIPES.length) { return endGame(true); }
      currentRecipe = RECIPES[level];
      spawnBenchFor(currentRecipe); buildSlots(currentRecipe);
    }
  });

  /* ===================== Inicio ===================== */
  overlay.style.display='flex';
  startBtn.addEventListener('click', startGame);

})();
</script>
</body>
</html>
